// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 02_users.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserEmailExist = `-- name: CheckUserEmailExist :one
SELECT email FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) CheckUserEmailExist(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, checkUserEmailExist, email)
	err := row.Scan(&email)
	return email, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (
  user_id,
	app_id,
	email,
  picture,
	role,
	is_active,
	given_name,
	family_name,
	name,
	refresh_token,
	created_at,
	is_deleted,
	updated_at
) VALUES (
  $1,$2,$3,$4,$5, $6,$7,$8,$9,$10,$11,$12,$13
) ON CONFLICT (app_id) DO UPDATE SET 
picture = COALESCE($14,picture),
given_name = COALESCE($15,given_name),
family_name = COALESCE($16,family_name),
name = COALESCE($17,name)
RETURNING user_id,created_at,updated_at, CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type CreateOrUpdateUserParams struct {
	UserID       int64
	AppID        string
	Email        string
	Picture      pgtype.Text
	Role         int16
	IsActive     bool
	GivenName    pgtype.Text
	FamilyName   pgtype.Text
	Name         pgtype.Text
	RefreshToken string
	CreatedAt    int64
	IsDeleted    bool
	UpdatedAt    int64
	Picture      pgtype.Text
	GivenName    pgtype.Text
	FamilyName   pgtype.Text
	Name         pgtype.Text
}

type CreateOrUpdateUserRow struct {
	UserID    int64
	CreatedAt int64
	UpdatedAt int64
	Operation string
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (CreateOrUpdateUserRow, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser,
		arg.UserID,
		arg.AppID,
		arg.Email,
		arg.Picture,
		arg.Role,
		arg.IsActive,
		arg.GivenName,
		arg.FamilyName,
		arg.Name,
		arg.RefreshToken,
		arg.CreatedAt,
		arg.IsDeleted,
		arg.UpdatedAt,
		arg.Picture,
		arg.GivenName,
		arg.FamilyName,
		arg.Name,
	)
	var i CreateOrUpdateUserRow
	err := row.Scan(
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Operation,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const findBySubID = `-- name: FindBySubID :one
SELECT user_id, app_id, email, picture, role, is_active, given_name, family_name, name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE app_id = $1 LIMIT 1
`

func (q *Queries) FindBySubID(ctx context.Context, appID string) (User, error) {
	row := q.db.QueryRow(ctx, findBySubID, appID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, userID int64) (string, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, userID)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUserActiveStatus = `-- name: GetUserActiveStatus :one
SELECT is_active FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserActiveStatus(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, getUserActiveStatus, email)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, app_id, email, picture, role, is_active, given_name, family_name, name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET 
email = COALESCE($1,email)  
WHERE user_id = $2
`

type UpdateUserParams struct {
	Email  pgtype.Text
	UserID int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.Email, arg.UserID)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET is_active = $1 WHERE email = $2
`

type UpdateUserActiveParams struct {
	IsActive bool
	Email    string
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Email)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users SET refresh_token = $2 WHERE user_id = $1
`

type UpdateUserTokenParams struct {
	UserID       int64
	RefreshToken string
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserToken, arg.UserID, arg.RefreshToken)
	return err
}
