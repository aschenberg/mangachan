// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: 02_users.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserEmailExist = `-- name: CheckUserEmailExist :one
SELECT email FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) CheckUserEmailExist(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, checkUserEmailExist, email)
	err := row.Scan(&email)
	return email, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  user_id,
	app_id,
	sub_id,
	email,
  picture,
	role,
	is_active,
	given_name,
	family_name,
	refresh_token,
	created_at,
	is_deleted,
	updated_at
) VALUES (
  $1,$2,$3,$4,$5, $6,$7,$8,$9,$10,$11,$12,$13
)
RETURNING user_id,created_at,updated_at
`

type CreateUserParams struct {
	UserID       int64
	AppID        string
	SubID        string
	Email        string
	Picture      pgtype.Text
	Role         int16
	IsActive     bool
	GivenName    pgtype.Text
	FamilyName   pgtype.Text
	RefreshToken string
	CreatedAt    int64
	IsDeleted    bool
	UpdatedAt    int64
}

type CreateUserRow struct {
	UserID    int64
	CreatedAt int64
	UpdatedAt int64
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.AppID,
		arg.SubID,
		arg.Email,
		arg.Picture,
		arg.Role,
		arg.IsActive,
		arg.GivenName,
		arg.FamilyName,
		arg.RefreshToken,
		arg.CreatedAt,
		arg.IsDeleted,
		arg.UpdatedAt,
	)
	var i CreateUserRow
	err := row.Scan(&i.UserID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const findBySubID = `-- name: FindBySubID :one
SELECT user_id, app_id, sub_id, email, picture, role, is_active, given_name, family_name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE sub_id = $1 LIMIT 1
`

func (q *Queries) FindBySubID(ctx context.Context, subID string) (User, error) {
	row := q.db.QueryRow(ctx, findBySubID, subID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.SubID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, userID int64) (string, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, userID)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUserActiveStatus = `-- name: GetUserActiveStatus :one
SELECT is_active FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserActiveStatus(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, getUserActiveStatus, email)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, app_id, sub_id, email, picture, role, is_active, given_name, family_name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.SubID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET 
email = COALESCE($1,email)  
WHERE user_id = $2
`

type UpdateUserParams struct {
	Email  pgtype.Text
	UserID int64
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.Email, arg.UserID)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET is_active = $1 WHERE email = $2
`

type UpdateUserActiveParams struct {
	IsActive bool
	Email    string
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Email)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users SET refresh_token = $2 WHERE user_id = $1
`

type UpdateUserTokenParams struct {
	UserID       int64
	RefreshToken string
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserToken, arg.UserID, arg.RefreshToken)
	return err
}
