// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: 02_users.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserEmailExist = `-- name: CheckUserEmailExist :one
SELECT email FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) CheckUserEmailExist(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, checkUserEmailExist, email)
	err := row.Scan(&email)
	return email, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (
  user_id,
	app_id,
	email,
  picture,
	role,
	is_active,
	given_name,
	family_name,
	name,
	refresh_token,
	is_deleted,
	created_at,
	updated_at
) VALUES (
  $1,$2,$3,$4,$5, $6,$7,$8,$9,$10,$11,$12,$13
) ON CONFLICT (app_id) DO UPDATE SET 
picture = COALESCE($4,picture),
given_name = COALESCE($14,given_name),
family_name = COALESCE($15,family_name),
name = COALESCE($9,name)
RETURNING user_id, app_id, email, picture, role, is_active, given_name, family_name, name, refresh_token, is_deleted, created_at, updated_at, CASE WHEN xmax = 0 THEN 'inserted' ELSE 'updated' END as operation
`

type CreateOrUpdateUserParams struct {
	ID           int64
	Appid        string
	Email        string
	Picture      pgtype.Text
	Role         int16
	Isactive     bool
	Givenname    pgtype.Text
	Familyname   pgtype.Text
	Name         pgtype.Text
	Refreshtoken string
	Isdeleted    bool
	Createdat    int64
	Updatedat    int64
	GivenName    pgtype.Text
	FamilyName   pgtype.Text
}

type CreateOrUpdateUserRow struct {
	UserID       int64
	AppID        string
	Email        string
	Picture      pgtype.Text
	Role         int16
	IsActive     bool
	GivenName    pgtype.Text
	FamilyName   pgtype.Text
	Name         pgtype.Text
	RefreshToken string
	IsDeleted    bool
	CreatedAt    int64
	UpdatedAt    int64
	Operation    string
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (CreateOrUpdateUserRow, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser,
		arg.ID,
		arg.Appid,
		arg.Email,
		arg.Picture,
		arg.Role,
		arg.Isactive,
		arg.Givenname,
		arg.Familyname,
		arg.Name,
		arg.Refreshtoken,
		arg.Isdeleted,
		arg.Createdat,
		arg.Updatedat,
		arg.GivenName,
		arg.FamilyName,
	)
	var i CreateOrUpdateUserRow
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Operation,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const findBySubID = `-- name: FindBySubID :one
SELECT user_id, app_id, email, picture, role, is_active, given_name, family_name, name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE app_id = $1 LIMIT 1
`

func (q *Queries) FindBySubID(ctx context.Context, appID string) (User, error) {
	row := q.db.QueryRow(ctx, findBySubID, appID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT refresh_token FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, userID int64) (string, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, userID)
	var refresh_token string
	err := row.Scan(&refresh_token)
	return refresh_token, err
}

const getUserActiveStatus = `-- name: GetUserActiveStatus :one
SELECT is_active FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserActiveStatus(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, getUserActiveStatus, email)
	var is_active bool
	err := row.Scan(&is_active)
	return is_active, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, app_id, email, picture, role, is_active, given_name, family_name, name, refresh_token, is_deleted, created_at, updated_at FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.AppID,
		&i.Email,
		&i.Picture,
		&i.Role,
		&i.IsActive,
		&i.GivenName,
		&i.FamilyName,
		&i.Name,
		&i.RefreshToken,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRefreshToken = `-- name: UpdateRefreshToken :exec
UPDATE users SET 
refresh_token = $1  
WHERE app_id = $2
`

type UpdateRefreshTokenParams struct {
	Refreshtoken string
	AppID        string
}

func (q *Queries) UpdateRefreshToken(ctx context.Context, arg UpdateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateRefreshToken, arg.Refreshtoken, arg.AppID)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET is_active = $1 WHERE email = $2
`

type UpdateUserActiveParams struct {
	IsActive bool
	Email    string
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Email)
	return err
}

const updateUserToken = `-- name: UpdateUserToken :exec
UPDATE users SET refresh_token = $2 WHERE user_id = $1
`

type UpdateUserTokenParams struct {
	UserID       int64
	RefreshToken string
}

func (q *Queries) UpdateUserToken(ctx context.Context, arg UpdateUserTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserToken, arg.UserID, arg.RefreshToken)
	return err
}
